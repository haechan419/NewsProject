import { useState, useEffect, useRef } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { fetchUserInfoAsync } from '../slices/authSlice';
import { updateProfile, getCategories, getMyCategories, updateCategories } from '../api/authApi';
import { registerFace } from '../api/faceApi';
import ProfileEditForm from '../components/auth/ProfileEditForm';
import './ProfileEdit.css';

const ProfileEdit = () => {
  const [nickname, setNickname] = useState('');
  const [selectedCategories, setSelectedCategories] = useState([]);
  const [availableCategories, setAvailableCategories] = useState([]);
  const [validationErrors, setValidationErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [successMessage, setSuccessMessage] = useState('');
  
  // 얼굴 등록 관련 상태
  const [faceImage, setFaceImage] = useState(null);
  const [facePreview, setFacePreview] = useState(null);
  const [isRegisteringFace, setIsRegisteringFace] = useState(false);
  const [faceMessage, setFaceMessage] = useState('');
  const fileInputRef = useRef(null);
  
  // 카메라 관련 상태
  const [isCameraActive, setIsCameraActive] = useState(false);
  const [cameraError, setCameraError] = useState('');
  const [isVideoReady, setIsVideoReady] = useState(false);
  const videoRef = useRef(null);
  const streamRef = useRef(null);

  const dispatch = useDispatch();
  const navigate = useNavigate();
  const { user, isLoading } = useSelector((state) => state.auth);

  // 사용자 정보 로드
  useEffect(() => {
    if (user) {
      setNickname(user.nickname || '');
      // 사용자 카테고리 로드
      if (user.categories) {
        setSelectedCategories(user.categories);
      }
    } else {
      // 사용자 정보가 없으면 조회 시도
      dispatch(fetchUserInfoAsync());
    }
  }, [user, dispatch]);

  // 사용자 정보가 로드된 후 닉네임 및 카테고리 설정
  useEffect(() => {
    if (user?.nickname) {
      setNickname(user.nickname);
    }
    if (user?.categories) {
      setSelectedCategories(user.categories);
    }
  }, [user]);

  // 카테고리 목록 로드
  useEffect(() => {
    const loadCategories = async () => {
      try {
        const categories = await getCategories();
        setAvailableCategories(categories);
      } catch (err) {
        console.error('카테고리 목록 로드 실패:', err);
        // 기본 카테고리 목록 설정
        setAvailableCategories(['정치', '경제', '엔터', 'IT/과학', '스포츠', '국제']);
      }
    };
    loadCategories();
  }, []);

  // 현재 사용자 카테고리 로드 (사용자 정보에 카테고리가 없는 경우)
  useEffect(() => {
    const loadUserCategories = async () => {
      if (user && (!user.categories || user.categories.length === 0)) {
        try {
          const categories = await getMyCategories();
          setSelectedCategories(categories);
        } catch (err) {
          console.error('사용자 카테고리 로드 실패:', err);
        }
      }
    };
    loadUserCategories();
  }, [user]);

  // OAuth 로그인으로 자동 생성된 닉네임인지 확인 (예: 한해찬_1, 한해찬_2)
  const isAutoGeneratedNickname = user?.nickname && /_\d+$/.test(user.nickname);

  // 카테고리 선택/해제 핸들러
  const handleCategoryToggle = (category) => {
    setSelectedCategories(prev => {
      if (prev.includes(category)) {
        // 이미 선택된 경우 제거
        return prev.filter(cat => cat !== category);
      } else {
        // 최대 3개까지만 선택 가능
        if (prev.length >= 3) {
          setValidationErrors({
            ...validationErrors,
            categories: '관심 카테고리는 최대 3개까지 선택할 수 있습니다.'
          });
          return prev;
        }
        setValidationErrors({
          ...validationErrors,
          categories: ''
        });
        return [...prev, category];
      }
    });
  };

  // 닉네임 유효성 검사
  const validateNickname = () => {
    const errors = {};

    if (!nickname.trim()) {
      errors.nickname = '닉네임을 입력해주세요.';
    } else if (nickname.trim().length < 2) {
      errors.nickname = '닉네임은 2자 이상이어야 합니다.';
    } else if (nickname.trim().length > 20) {
      errors.nickname = '닉네임은 20자 이하여야 합니다.';
    } else if (!/^[가-힣a-zA-Z0-9]+$/.test(nickname.trim())) {
      errors.nickname = '닉네임은 한글, 영문, 숫자만 사용할 수 있습니다.';
    }

    setValidationErrors(prev => ({ ...prev, ...errors }));
    return Object.keys(errors).length === 0;
  };

  // 카테고리 유효성 검사
  const validateCategories = () => {
    const errors = {};

    if (selectedCategories.length > 3) {
      errors.categories = '관심 카테고리는 최대 3개까지 선택할 수 있습니다.';
    }

    setValidationErrors(prev => ({ ...prev, ...errors }));
    return Object.keys(errors).length === 0;
  };

  // 닉네임 수정 핸들러
  const handleNicknameSubmit = async (e) => {
    e.preventDefault();
    setValidationErrors(prev => ({ ...prev, nickname: '' }));
    setSuccessMessage('');

    if (!validateNickname()) {
      return;
    }

    // 변경 사항 확인은 백엔드에서 처리하므로 여기서는 제거
    // (같은 닉네임일 경우 백엔드에서 "중복되는 닉네임입니다" 에러 반환)

    setIsSubmitting(true);

    try {
      await updateProfile(nickname.trim());
      
      // Redux 상태 업데이트
      dispatch(fetchUserInfoAsync());
      
      setSuccessMessage('닉네임이 성공적으로 수정되었습니다!');
    } catch (error) {
      // 에러를 조용히 처리 (콘솔에 로그하지 않음)
      const errorMessage = error.response?.data?.message || error.message || '닉네임 수정에 실패했습니다.';
      setValidationErrors(prev => ({ ...prev, nickname: errorMessage }));
      // 에러를 조용히 처리하기 위해 에러를 다시 throw하지 않음
    } finally {
      setIsSubmitting(false);
    }
  };

  // 카테고리 수정 핸들러
  const handleCategoriesSubmit = async (e) => {
    e.preventDefault();
    setValidationErrors(prev => ({ ...prev, categories: '' }));
    setSuccessMessage('');

    if (!validateCategories()) {
      return;
    }

    // 변경 사항 확인 (배열 복사 후 정렬하여 원본 배열 변경 방지)
    const categoriesChanged = JSON.stringify([...selectedCategories].sort()) !== JSON.stringify([...(user?.categories || [])].sort());

    if (!categoriesChanged) {
      setSuccessMessage('변경 사항이 없습니다.');
      return;
    }

    setIsSubmitting(true);

    try {
      await updateCategories(selectedCategories);
      
      // Redux 상태 업데이트
      dispatch(fetchUserInfoAsync());
      
      setSuccessMessage('관심 카테고리가 성공적으로 수정되었습니다!');
    } catch (error) {
      // 에러를 조용히 처리 (콘솔에 로그하지 않음)
      const errorMessage = error.response?.data?.message || error.message || '카테고리 수정에 실패했습니다.';
      setValidationErrors(prev => ({ ...prev, categories: errorMessage }));
      // 에러를 조용히 처리하기 위해 에러를 다시 throw하지 않음
    } finally {
      setIsSubmitting(false);
    }
  };

  // 취소 핸들러
  const handleCancel = () => {
    navigate('/');
  };

  // 얼굴 이미지 선택 핸들러
  const handleFaceImageSelect = (e) => {
    const file = e.target.files[0];
    if (file) {
      // 파일 크기 검증 (10MB 제한)
      if (file.size > 10 * 1024 * 1024) {
        setFaceMessage('이미지 크기는 10MB 이하여야 합니다.');
        return;
      }

      // 이미지 파일 검증
      if (!file.type.startsWith('image/')) {
        setFaceMessage('이미지 파일만 업로드 가능합니다.');
        return;
      }

      const reader = new FileReader();
      reader.onloadend = () => {
        setFacePreview(reader.result);
        setFaceImage(reader.result);
        setFaceMessage('');
      };
      reader.readAsDataURL(file);
    }
  };

  // 얼굴 등록 핸들러
  const handleRegisterFace = async () => {
    if (!faceImage) {
      setFaceMessage('이미지를 선택해주세요.');
      return;
    }

    if (!user?.email) {
      setFaceMessage('사용자 정보를 불러올 수 없습니다.');
      return;
    }

    setIsRegisteringFace(true);
    setFaceMessage('얼굴을 분석하고 데이터베이스에 저장하는 중...');

    try {
      // Base64 데이터에서 헤더 제거 (이미 data:image/... 형식이므로 그대로 사용)
      const response = await registerFace(
        faceImage,
        user.email, // userId로 email 사용
        user.nickname || user.email // userName
      );

      if (response.success && response.data?.success) {
        setFaceMessage('얼굴 등록이 완료되었습니다! 데이터베이스에 저장되었습니다.');
        // 성공 메시지 표시 후 3초 뒤 초기화
        setTimeout(() => {
          setFaceImage(null);
          setFacePreview(null);
          setFaceMessage('');
          if (fileInputRef.current) {
            fileInputRef.current.value = '';
          }
        }, 3000);
      } else {
        const errorMsg = response.data?.message || response.message || '얼굴 등록에 실패했습니다.';
        setFaceMessage(errorMsg);
      }
    } catch (error) {
      const errorMessage = error.response?.data?.data?.message || 
                          error.response?.data?.error || 
                          error.message || 
                          '얼굴 등록 중 오류가 발생했습니다.';
      setFaceMessage(errorMessage);
    } finally {
      setIsRegisteringFace(false);
    }
  };

  // 얼굴 이미지 초기화
  const handleResetFace = () => {
    setFaceImage(null);
    setFacePreview(null);
    setFaceMessage('');
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
    // 카메라가 활성화되어 있으면 종료
    if (isCameraActive) {
      stopCamera();
    }
  };

  // 카메라 시작
  const startCamera = async () => {
    console.log('카메라 시작 함수 호출됨');
    try {
      setCameraError('');
      setFaceMessage('');
      setIsCameraActive(true); // 먼저 활성화하여 로딩 화면 표시
      setIsVideoReady(false);
      
      // 카메라 지원 여부 확인
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        console.error('카메라를 지원하지 않는 브라우저');
        setCameraError('이 브라우저는 카메라를 지원하지 않습니다.');
        // 에러 메시지를 보여주기 위해 isCameraActive는 true로 유지
        return;
      }

      console.log('카메라 권한 요청 중...');
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 640 },
          height: { ideal: 480 },
          facingMode: 'user' // 전면 카메라 우선
        },
        audio: false
      });
      
      console.log('카메라 스트림 받음:', stream);
      streamRef.current = stream;
      
      // 비디오 요소가 준비될 때까지 대기
      const setupVideo = () => {
        if (videoRef.current) {
          console.log('비디오 요소에 스트림 할당');
          const video = videoRef.current;
          video.srcObject = stream;
          setIsVideoReady(false);
          
          // 비디오 로드 및 재생 보장
          let timeoutId = null;
          
          // 비디오 준비 완료 처리 함수
          const handleVideoReady = () => {
            if (timeoutId) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            setIsVideoReady(true);
          };
          
          // 비디오 메타데이터 로드 완료 시
          video.onloadedmetadata = () => {
            console.log('비디오 메타데이터 로드 완료');
            video.play()
              .then(() => {
                console.log('비디오 재생 시작');
                handleVideoReady();
              })
              .catch(err => {
                console.error('비디오 재생 에러:', err);
                // 재생 실패해도 비디오는 표시
                handleVideoReady();
              });
          };
          
          // 비디오 재생 시작 이벤트
          video.onplaying = () => {
            console.log('비디오 재생 중');
            handleVideoReady();
          };
          
          // 비디오 로드 시작 이벤트
          video.onloadstart = () => {
            console.log('비디오 로드 시작');
          };
          
          // 에러 발생 시에도 비디오 표시 시도
          video.onerror = (err) => {
            console.error('비디오 에러:', err);
            // 에러가 발생해도 일정 시간 후 표시 시도
            setTimeout(() => {
              if (videoRef.current && videoRef.current.srcObject) {
                handleVideoReady();
              }
            }, 1000);
          };
          
          // 타임아웃 설정: 3초 후에도 준비되지 않으면 강제로 표시
          timeoutId = setTimeout(() => {
            if (videoRef.current && videoRef.current.srcObject) {
              console.log('타임아웃: 비디오 강제 표시');
              handleVideoReady();
            }
          }, 3000);
        } else {
          // 비디오 요소가 아직 준비되지 않았으면 잠시 후 다시 시도
          console.log('비디오 요소가 아직 준비되지 않음, 재시도...');
          setTimeout(setupVideo, 100);
        }
      };
      
      setupVideo();
    } catch (error) {
      console.error('카메라 접근 에러:', error);
      let errorMessage = '카메라에 접근할 수 없습니다.';
      
      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
        errorMessage = '카메라 권한이 거부되었습니다. 브라우저 설정에서 카메라 권한을 허용해주세요.';
      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
        errorMessage = '카메라를 찾을 수 없습니다. 카메라가 연결되어 있는지 확인해주세요.';
      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
        errorMessage = '카메라에 접근할 수 없습니다. 다른 애플리케이션에서 카메라를 사용 중일 수 있습니다.';
      }
      
      setCameraError(errorMessage);
      // 에러 메시지를 보여주기 위해 isCameraActive는 true로 유지
      console.error('카메라 에러 메시지 설정:', errorMessage);
    }
  };

  // 카메라 종료
  const stopCamera = () => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
      streamRef.current = null;
    }
    if (videoRef.current) {
      videoRef.current.srcObject = null;
    }
    setIsCameraActive(false);
    setIsVideoReady(false);
  };

  // 사진 촬영 및 바로 등록
  const capturePhoto = async () => {
    if (!videoRef.current) {
      setFaceMessage('카메라가 준비되지 않았습니다.');
      return;
    }

    const video = videoRef.current;
    
    // 비디오가 로드되었는지 확인
    if (video.readyState !== video.HAVE_ENOUGH_DATA) {
      setFaceMessage('카메라가 아직 준비되지 않았습니다. 잠시 후 다시 시도해주세요.');
      return;
    }

    if (!user?.email) {
      setFaceMessage('사용자 정보를 불러올 수 없습니다.');
      return;
    }

    // 촬영 중 상태 표시
    setIsRegisteringFace(true);
    setFaceMessage('사진을 촬영하고 등록하는 중...');

    try {
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth || 640;
      canvas.height = video.videoHeight || 480;
      
      const ctx = canvas.getContext('2d');
      // 좌우 반전된 비디오를 원래대로 되돌림
      ctx.translate(canvas.width, 0);
      ctx.scale(-1, 1);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      // Canvas를 Base64 이미지로 변환
      const imageData = canvas.toDataURL('image/png');
      
      // 카메라 종료
      stopCamera();
      
      // 미리보기 설정
      setFacePreview(imageData);
      setFaceImage(imageData);
      
      // 바로 얼굴 등록 API 호출 (DB에 저장됨)
      const response = await registerFace(
        imageData,
        user.email, // userId로 email 사용
        user.nickname || user.email // userName
      );

      if (response.success && response.data?.success) {
        setFaceMessage('얼굴 등록이 완료되었습니다! 데이터베이스에 저장되었습니다.');
        // 성공 메시지 표시 후 3초 뒤 초기화
        setTimeout(() => {
          setFaceImage(null);
          setFacePreview(null);
          setFaceMessage('');
        }, 3000);
      } else {
        const errorMsg = response.data?.message || response.message || '얼굴 등록에 실패했습니다.';
        setFaceMessage(errorMsg);
        // 실패 시 이미지는 유지하여 재시도 가능하게 함
      }
    } catch (error) {
      console.error('얼굴 등록 에러:', error);
      const errorMessage = error.response?.data?.data?.message || 
                          error.response?.data?.message ||
                          error.response?.data?.error || 
                          error.message || 
                          '얼굴 등록 중 오류가 발생했습니다.';
      setFaceMessage(errorMessage);
      // 에러 발생 시에도 이미지는 유지하여 재시도 가능하게 함
    } finally {
      setIsRegisteringFace(false);
    }
  };

  // 카메라 모드 토글
  const handleCameraToggle = () => {
    console.log('카메라 토글 버튼 클릭됨, 현재 상태:', isCameraActive);
    if (isCameraActive) {
      console.log('카메라 종료');
      stopCamera();
    } else {
      console.log('카메라 시작');
      // 기존 이미지가 있으면 초기화
      if (facePreview) {
        setFaceImage(null);
        setFacePreview(null);
        if (fileInputRef.current) {
          fileInputRef.current.value = '';
        }
      }
      startCamera();
    }
  };

  const handleNicknameChange = (e) => {
    setNickname(e.target.value);
    setValidationErrors({ ...validationErrors, nickname: '' });
    setSuccessMessage('');
  };

  // 비디오가 준비되면 재생 보장
  useEffect(() => {
    if (isCameraActive && videoRef.current && streamRef.current) {
      const video = videoRef.current;
      
      // 비디오가 재생 중이 아니면 재생 시도
      if (video.paused && video.readyState >= video.HAVE_METADATA) {
        video.play().catch(err => {
          console.error('비디오 재생 에러:', err);
        });
      }
    }
  }, [isCameraActive, isVideoReady]);

  // 컴포넌트 언마운트 시 카메라 정리
  useEffect(() => {
    return () => {
      if (streamRef.current) {
        streamRef.current.getTracks().forEach(track => track.stop());
      }
    };
  }, []);

  if (isLoading && !user) {
    return (
      <div className="profile-edit-container">
        <div className="profile-edit-box">
          <div style={{ textAlign: 'center', padding: '40px' }}>
            <div className="loading-spinner"></div>
            <p style={{ marginTop: '20px', color: '#666' }}>사용자 정보를 불러오는 중...</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <ProfileEditForm
      user={user}
      nickname={nickname}
      onNicknameChange={handleNicknameChange}
      selectedCategories={selectedCategories}
      availableCategories={availableCategories}
      onCategoryToggle={handleCategoryToggle}
      validationErrors={validationErrors}
      successMessage={successMessage}
      isSubmitting={isSubmitting}
      isLoading={isLoading}
      isAutoGeneratedNickname={isAutoGeneratedNickname}
      onNicknameSubmit={handleNicknameSubmit}
      onCategoriesSubmit={handleCategoriesSubmit}
      onCancel={handleCancel}
      isCameraActive={isCameraActive}
      isVideoReady={isVideoReady}
      cameraError={cameraError}
      isRegisteringFace={isRegisteringFace}
      facePreview={facePreview}
      faceMessage={faceMessage}
      videoRef={videoRef}
      fileInputRef={fileInputRef}
      onCameraToggle={handleCameraToggle}
      onFaceImageSelect={handleFaceImageSelect}
      onCapturePhoto={capturePhoto}
      onStopCamera={stopCamera}
      onRegisterFace={handleRegisterFace}
      onResetFace={handleResetFace}
    />
  );
};

export default ProfileEdit;
